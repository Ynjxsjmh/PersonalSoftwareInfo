* 第四章 指针和数组
** 4.2 数组
*** 4.2.1 数组的内存分布
我们定义一个数组a时，编译器根据指定的元素个数和元素类型分配确定大小（元素类型大小×元素个数）的一块内存，并把这个内存的名字命名为a

sizeof(a)的值为sizeof(int)*5，32位系统下为20。
sizeof(a[0])的值为sizeof(int)，32位系统下为4。
sizeof(&a[0])的值在32位系统下为4，取元素a[0]的首地址
sizeof(&a)的值在32位系统下为4，取数组a的首地址（地址都是4字节表示的）

*** 4.2.2 省政府和市政府的区别――&a[0]和&a的区别
&a[0]是数组首元素的地址，&a是数组的首地址。
虽然二者值一样，但是意义不一样
#+BEGIN_SRC C
#include <stdio.h>

int main() {
  int a[5] = {1,2,3,4,5};
  printf("%x, %x\n", &a, &a[0]);
  printf("%x, %x", (&a+1), (&a[0]+1));
  return 0;
}

output:
1c4661e0, 1c4661e0
1c4661f4, 1c4661e4
#+END_SRC

*** 4.2.3 数组名a作为左值和右值的区别
a作为右值时代表的含义和&a[0]一样，代表的是数组元素的首地址，而不是数组的首地址。（在用表达式sizeof(a)中时，a表示的是数组名，此时a并没有被用作右值）
注意，这仅仅是代表，并没有一个地方来存储这个地址，也就是说编译器并没有为数组a分配一块内存来存储其地址。

*a不能作为左值！* 编译器会认为数组名作为左值代表的意思是a的首元素的首地址，但是这个地址开始的一块内存是一个总体，我们只能访问数组的某个元素，而无法把数组当一个整体进行访问。

** 4.3 指针和数组之间的恩恩怨怨
*** 4.3.2 a和&a的区别
#+BEGIN_SRC C
int main() {
  int a[5] = {1,2,3,4,5};
  int *ptr = (int *)(&a+1);
  printf("%d, %d", *(a+1),*(ptr-1));
  return 0;
}

output:
2, 5
#+END_SRC


*解析：*
对指针进行加1操作，得到的是下一个元素的地址，而不是原有地址值直接加1.
因此，一个类型为T的指针的移动，以~sizeof(T)~为移动单位。
对上题来说，a是一个一维数组，数组有5个元素；ptr是一个int型的指针。
=&a+1= ：取数组a的首地址，在该地址的值上加上sizeof(a)的值，即 =&a+5*sizeof(int)=，也就是下一个数组的首地址，当然当前指针已经越过了数组的界限。
=(int *)(&a+1)= ：这一步是把上一步计算出来的地址强制转化为=int *=类型，并赋值给ptr
=*(a+1)= ：a和&a的值是一样的，但是意思不一样:
1.a是数组首元素的首地址，也就是a[0]的首地址；而&a是数组的首地址。
2.a+1是数组下一元素的首地址，即a[1]的首地址；&a+1是下一个数组的首地址
=*(ptr-1)= ：因为ptr指向的是a[5]，并且ptr是int *类型，所以*(ptr-1)指向a[5]

** 4.4 指针数组和数组指针
** 4.4.3 再论a和&a之间的区别
#+BEGIN_SRC C
#include <stdio.h>

int main() {
	char a[5] = {'A', 'B', 'C', 'D'};
	printf("%x\n", a);
	
	char (*p3)[5] = &a;
	char (*p4)[5] = a;
	printf("%x ", (p3+1));
	printf("%x\n", (p4+1));
	
	char (*p5)[3] = &a;
	char (*p6)[3] = &a;
	printf("%x ", (p5+1));
	printf("%x\n", (p6+1));
	
	char (*p7)[10] = &a;
	char (*p8)[10] = &a;
	printf("%x ", (p7+1));
	printf("%x\n", (p8+1));
	return 0;
}
#+END_SRC

#+RESULTS:
| ffffcb6b |          |
| ffffcb70 | ffffcb70 |
| ffffcb6e | ffffcb6e |
| ffffcb75 | ffffcb75 |
output:
75a1e490
75a1e495 75a1e495
75a1e493 75a1e493
75a1e49a 75a1e49a

上面对p3和p4等指针的使用，哪个正确？

*解析：*
毫无疑问，p3和p4都是数组指针，指向的是整个数组。&a是整个数组的首地址，a是数组首元素的首地址，值虽然相同，但意义不同。
在C语言里，赋值符号”=“两边的数据类型必须是相同的，如果不相同则需要显示或隐式的类型转换。
p3这个定义中，”=“两边的数据类型完全一致。
p4这个定义就不是了：左边的类型是指向整个数组的指针，右边的数据类型是指向单个字符的指针。一般编译通不过，但是在Visual C++ 6.0只是给出警告。由于&a和a的值一样，而变量作为右值时编译器只是取变量的值，所以在该IDE中运行没有问题。
既然知道了，p3和p4都是指向整个数组的，那么+1后的值就很好理解了。
